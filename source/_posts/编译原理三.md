---
title: æ–¯å¦ç¦cs231(ç¼–è¯‘åŸç†)ã® 3 Parsing Analysis 1 (Introduction & LL Analysis)
date: 2023-06-10 18:06:16
tags: ç¼–è¯‘åŸç†ï¼Œè®¡ç®—æœºåŸºç¡€ï¼Œcool
math: true
categories: ç¼–è¯‘åŸç†
---

## Introduction

Regular languages

- The weakest formal languages widely used
- Many applications



æ­£åˆ™è¡¨è¾¾å¼çš„ç¼ºé™·ï¼š

- 



Parserï¼š

- Input: sequence of tokens from lexer
- Output: parse tree pf the program



```
Cool:
	if x = y then 1 else 2 fi
Parser input:
	IF ID = ID THEN INT ELSE INT FI
Parser output:
		 IF-THEN-ELSE
	=      INT      INT
ID ID    
```

| Phase  | Intput               | Output           |
| ------ | -------------------- | ---------------- |
| Lexer  | String of characters | String of tokens |
| Parser | String of tokens     | Parse tree       |

> ä¸Šé¢ä¸¤æ­¥æœ‰çš„ç¼–è¯‘å™¨æ˜¯åˆ†å¼€åšçš„ï¼Œæœ‰çš„ç¼–è¯‘å™¨æ˜¯æ”¾åœ¨ä¸€èµ·åšçš„



## ä¸Šä¸‹æ— å…³æ–‡æ³•

ç”±è¯æ³•åˆ†æå™¨å¾—åˆ°çš„tokenså¹¶ä¸å…¨æ˜¯æœ‰ç”¨çš„ï¼Œæ¯”å¦‚æ ‡ç‚¹ç¬¦å·ï¼Œæ‰€ä»¥ç¼–è¯‘å™¨å¿…é¡»è¯†åˆ«å“ªäº›æ˜¯æœ‰æ•ˆtokenï¼Œå“ªäº›æ˜¯æ— æ•ˆçš„ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ç§æè¿°è§„åˆ™æ¥æè¿°ä½•ä¸ºæœ‰æ•ˆtokenï¼Œä»¥åŠä¸€ç§è¯†åˆ«æœ‰æ•ˆtokençš„æ–¹æ³•



ç¨‹åºè¯­è¨€éƒ½æ˜¯æœ‰ç€nested(é€’å½’)çš„ç»“æ„ï¼Œå¦‚ï¼š

```
EXPR = if EXPR then EXPR else EXPR fi
	while EXPR loop EXPR pool
```

**ä¸Šä¸‹æ— å…³æ–‡æ³•æ®è¯´ä¸€ç§æè¿°è¿™ç§é€’å½’ç»“æ„çš„natural notation**



CFG ç”±ä¸‹é¢å‡ éƒ¨åˆ†æ„æˆï¼š

- a set of terminals: $T$
- a set of nn-terminals: $N$
- a start symbol: $S (S \in N)$
- a set of productions:$ X -> Y_1, ... Y_N (X \in N, Y_i \in N \cup T \cup \{\epsilon\})$



1. Begin with a string with only the start symbol S
2. Replace any non-terminal X in the string by the right-hand side of some production
3. Repeat (2) until there are non-terminals





let G be a contexto-free grammar with start symbol S. Then the language L(G) of is:
$$
\{ a_1, ... a_n \quad | \quad \forall_i \quad a_i \in T \and S \mathop{\rightarrow}^* a_1, ..., a_n \}
$$

- Terminals are so-called because there are no-reulses for replacing them ç»ˆç»“ç¬¦æ˜¯ä¸å˜çš„
- Once generated, terminals are permanentï¼Œç»ˆç»“ç¬¦æ˜¯ä¸å˜çš„
- Terminals ought to be tokens of the language (ç»ˆç»“ç¬¦ä¸€èˆ¬æ˜¯è¯­è¨€çš„tokenï¼Œæ¯”å¦‚å…³é”®å­—ï¼Œæ ‡è¯†ç¬¦)

ğŸŒ°ï¼š

```
E -> E + E
	 | E * E
	 | (E)
	 | id
	 
å¯¹åº”çš„è¯­è¨€ï¼š
id
id + id
id + id * id
(id + id) * id
```



æ•´ä¸ªCFGæ˜¯ä¸€ä¸ªå¾ˆå¤§çš„æ­¥éª¤ï¼Œéœ€è¦ï¼š

- Membership in a alnguage is yes or no, also parse tree of the input
- Must handle errors gracefully
- Need an implementation of CFG's (eg: bison)



## Derivations(æ¨å¯¼)

A derivations s a **sequence** f production:
$$
S -> .. -> ,,, -> ... -> ..
$$
æ¨å¯¼è¿‡ç¨‹å¯ä»¥ä»¥æ ‘çš„å½¢å¼ç”»å‡ºæ¥ï¼š

- start symbol is the tree's root
- For a production $X->Y_1Y_2..Y_n$ add children $Y_1Y_2...Y_n$ o node X



è€ƒè™‘ä¸‹é¢è¯­æ³•ï¼š
$$
E â†’ E + E |  E * E | (E) | id
$$
ä»¥åŠå­—ç¬¦ä¸²ï¼šid * id + id



![image-20230617134603437](/Users/bytedance/Library/Application Support/typora-user-images/image-20230617134603437.png)

A parse  tree has 

- Terminals at the leaves
- Non-terminals at the interior nodes

> å¯¹å¶å­èŠ‚ç‚¹çš„in-orderéå†å°±æ˜¯åŸå§‹è¾“å‡ºï¼Œparse treeè¡¨ç¤ºäº†tokenä¹‹é—´çš„å„ç§å…³ç³»
>
> å¦‚ä¸‹ï¼š
>
> å¶å­èŠ‚ç‚¹ä»å·¦åˆ°å³ï¼šå°±æ˜¯åŸå§‹è¾“å…¥ï¼šid * id + id
>
> ä¸­é—´èŠ‚ç‚¹å’Œå·¦å³å…„å¼ŸèŠ‚ç‚¹çš„å…³ç³»ä¹Ÿå¾ˆæ˜ç¡®ï¼Œ*çš„å·¦å³å°±æ˜¯id





ä¸Šè¿°æ¨å¯¼å¼çš„äº§ç”Ÿæ˜¯left-mostï¼Œå³åœ¨æ¯ä¸€æ­¥ä¼˜å…ˆæ¨å¯¼æœ€å·¦è¾¹çš„ç¬¦å·ï¼ˆå³æ¨å¯¼æ–¹å‘æ˜¯è‡ªå·¦å‘å³ï¼‰ï¼Œä½†æ˜¯è¿™æ ·å¯èƒ½ä¼šå‡ºç°æ²¡æœ‰ç»“æŸæ¡ä»¶è€Œä¸€ç›´æ— é™æ¨å¯¼ä¸‹å»ã€‚è¿˜æœ‰ä¸€ç§ä¸ä¹‹ç±»ä¼¼çš„right-most æ¨å¯¼

```
E
-> E + E
-> E + id
-> E * E + id
-> E * id + id
-> id * id + id
```

> Note that r-most and l-most derivations have the same parse tree
>
> A derivations defines a parse tree, but one parse tree may have many derivations
>
> ä¸€ä¸ªParse tree å¯èƒ½æœ‰å¾ˆå¤šç§æ¨å¯¼æ–¹å¼å¯ä»¥å¾—åˆ°ï¼Œä½†æ˜¯æœ€å·¦æ¨å¯¼å’Œæœ€å³æ¨å¯¼æ˜¯æœ€é‡è¦çš„ä¸¤ç§æ–¹å¼



**Conclusion**:

- ä¸ä»…å¯¹æŸä¸ªå­—ç¬¦ä¸²æ˜¯å¦å±äºL(G)(è¯­æ³•Gæ‰€äº§ç”Ÿçš„è¯­è¨€)æ„Ÿå…´è¶£ï¼Œä¹Ÿéœ€è¦å¯¹åº”çš„è§£ææ ‘
- ä¸€ä¸ªæ¨å¯¼å¼å®šä¹‰äº†ä¸€ä¸ªè§£ææ ‘ï¼ˆæˆ–è€…è§£ææ ‘çš„ä¸€éƒ¨åˆ†ï¼‰ï¼ŒåŒä¸€ä¸ªParse tree å¯èƒ½æœ‰å¾ˆå¤šç§æ¨å¯¼æ–¹å¼å¯ä»¥å¾—åˆ°



## Ambiguity(è¯­æ³•çš„äºŒä¹‰æ€§)

### è§£æä¼˜å…ˆçº§

Grammar: E -> E + E | E * E | (E) | id

String stream: id * id + id

ä¸åŒçš„æ¨å¯¼å¾—åˆ°ä¸åŒçš„parse treeï¼š

```
		E
	E + E
E * E id
id  id 

		E
	E  *  E
  id  E + E
		 id   id 
```

> A grammar is ambiguous if it has more than one parse tree for some string, æ¢å¥è¯è¯´ï¼Œå¯¹äºæŸäº›å­—ç¬¦ä¸²ï¼Œå¯ä»¥ç”±è¶…è¿‡ä¸€ç§çš„åšä½œæˆ–æœ€å³æ¨å¯¼æ–¹å¼

**How to handle ambiguous**

Method 1:

é‡å†™è¯­æ³•ï¼šå…¶å®æœ¬è´¨ä¸Šæ˜¯å¼ºåˆ¶äº†è§£ææ—¶å€™çš„ä¼˜å…ˆçº§

```
E -> E' + E/E'
E' -> id * E' | id | (E) * E'| (E) 
```





Method 2ï¼š

ä¸é‡å†™ï¼Œä½†æ˜¯åœ¨è§£æçš„æ—¶å€™ï¼Œä½¿ç”¨ä¼˜å…ˆçº§æˆ–è€…åˆ¤æ–­å“ªä¸ªæ˜¯æœ€ä¼˜çš„

### ç»“åˆæ€§





## Parsing Error Handle(parserè¿‡ç¨‹çš„é”™è¯¯å¤„ç†)



| Error kind  | Example                                                      | Detected by                    |
| ----------- | ------------------------------------------------------------ | ------------------------------ |
| Lexical     | ä½¿ç”¨äº†æœªçŸ¥ç¬¦å·ï¼Œæ¯”å¦‚elseå†™æˆäº†eles                           | Lexer                          |
| Syntax      | ç¼–å†™çš„ç¨‹åºå­˜åœ¨ç»“æ„é”™è¯¯ï¼Œæ¯”å¦‚whileåé¢åº”è¯¥æœ‰ä¸€å¯¹{}, ä½†æ˜¯åªå†™äº†ä¸€ä¸ª{ | parser                         |
| Semantic    | int x; x(3);å£°æ˜xä¸ºæ™®é€šå˜é‡ï¼Œä½†æ˜¯å´æŠŠxå½“æˆå‡½æ•°ä½¿ç”¨           | Type Checker                   |
| Correctness | è‡ªå·±çš„ä»£ç è™½ç„¶é€šè¿‡äº†ç¼–è¯‘å™¨ï¼Œä½†æ˜¯è¿è¡Œç»“æœä¸ç¬¦åˆé¢„æœŸ           | User/Testerï¼Œä¸€èˆ¬éœ€è¦è‡ªå·±debug |

Error handler should:

- Report errors accurately and clearly
- Recover from an error quickly
- Not slow down compilation of valid code

å¸¸è§çš„ä¸‰ç§ä¸åŒé”™è¯¯å¤„ç†æ¨¡å¼ï¼š

- Panic Mode (ä½¿ç”¨ç‰¹æ®Šçš„ç»ˆæ­¢ç¬¦(error)åƒæ‰é”™è¯¯ï¼Œç»§ç»­æ‰§è¡Œ)
  - When an error is detected
    - Discard tokens until one with clear role is found
    - Continue from here

â€‹	ğŸŒ°ï¼š

```
(1 + + 2) + 2
skip ahead to next interger and then continue
```

Bison: use the special terminal error to descide how mucg input to skip

```
E -> int | E + E | (E) | error int | (error)
```



- Error productions (æ·»åŠ å¯èƒ½çš„é”™è¯¯çš„æ¨å¯¼å¼): specify known common mistakes in the grammar

  Eg: write 5 x instead of 5 * x

  Add production E -> .... | E E

  Disadvantage: complicates the grammar

- Automatic local or global correction 

  - Find a correct "nearby" program
    - try token insertions and deletions (ç¼–è¾‘è·ç¦»)
    - exhaustive search
  - Disadvantages:
    - hard to impl
    - slows down parsing of correct programs
    - "nearby" is not necessarily "the intended" program

Past:

- Slow recompilation cycle (even once a day)
- rind as many errors in one cycle as possible



Present:

- Quick recompilation cycle
- users tend to correct one error/cycle
- Complex error recovery is less compelling

## Another Clean Parse Tree Form â€”â€” AST

Parserè·Ÿè¸ª(trace)ä¸€ä¸ªtokenåºåˆ—çš„æ¨å¯¼è¿‡ç¨‹ï¼Œå¹¶ç”±æ­¤äº§ç”ŸParse tree

ğŸŒ°ï¼š

Grammar: E -> int | (E) | E + E

After lexical analysis: [Int(2), '+', '(', Int(1), '+', 'Int(5), ')']



Parse Tree:

```
	E
E + E
int(2) (E)
		E + E
		int(1) int(5)
```

ASTï¼š

```
[Plus, leftO, rightO]
				Int(2)  [Plus, leftO, rightO]
												Int(1) Int(5)
```

è¢«ç§°ä¹‹ä¸ºASTï¼Œå› ä¸ºå®ƒä»å…·ä½“è¯­æ³•ä¸­æŠ½è±¡å‡ºæ¥ï¼Œç…ç‚’äº†å…·ä½“è¯­æ³•çš„ç»†èŠ‚ï¼›è€ŒParse Treeå±•ç¤ºäº†å…·ä½“çš„æ¨å¯¼è§„åˆ™å’Œç›¸å…³ç»“æ„ï¼Œå¯¹äºç¼–è¯‘å™¨æ¥æ°´è¯´ï¼Œæœ‰å¾ˆå¤šä¸å¿…è¦çš„å†…å®¹





### é€’å½’ä¸‹é™è§£æ

è§£ææ ‘ä¸€èˆ¬æŒ‰ç…§å¦‚ä¸‹æ–¹å¼æ„å»ºï¼š

- è‡ªä¸Šè‡³ä¸‹
- ä»å·¦åˆ°å³

```
		1
t2. 3.  t9
   4. 7 
  t5. t6.  t8
```

Tokens: [t2, t5, t6, t8, t9]



çœ‹ä¸€ä¸ªè¯¦ç»†çš„é€’å½’ä¸‹é™è§£æçš„ğŸŒ°ï¼š

è€ƒè™‘è¯­æ³•Grammar: 

E -> T | T | T + E

T -> int | int * T | (E)



è¾“å…¥ï¼š$(int_5)$

æ­¥éª¤ï¼š

ä»èµ·å§‹è²ç»ˆç»“ç¬¦å¼€å§‹ï¼Œä¾æ¬¡å°è¯•å…³äºEçš„æ¨å¯¼å¼



```
E -> T -> int (mismatch: int does not match (, backtrack) =>
		 T -> [int * T] (mismatch: int does not match (, backtrack) =>
		 T -> ( E ) (match: ç»§ç»­ä¸‹ä¸€ä¸ªè¾“å…¥å­—ç¬¦int =>
		 T -> ( E -> int ) (match: ç»§ç»­ä¸‹ä¸€ä¸ªè¾“å…¥å­—ç¬¦) =>
```





é€’å½’ä¸‹é™è§£æç®—æ³•çš„ä¸€èˆ¬å®šä¹‰å¦‚ä¸‹ï¼š

é¦–å…ˆå®šä¹‰å‡ ä¸ªå…³äºæ˜¯å¦ç¬¦åˆæŸä¸ªåŒ¹é…çš„å‡½æ•°ï¼š

- æ˜¯å¦ä¸ºç»ˆç»“ç¬¦ï¼š

  ```
  bool term(TOKEN tok) {return *next++ == tok}
  ```

- æ˜¯å¦ä¸ºlfsä¸ºSç¬¬nä¸ªæ¨å¯¼å¼ï¼š

  ```
  bool Sn() {}
  ```

- æ˜¯å¦ä¸ºlfsä¸ºSçš„æ¨å¯¼å¼

  ```
  bool S() {}
  ```

ğŸŒ°ï¼š

- E -> T: bool E1() { return T() }

- E -> T + E: bool E2() { return T() && term(PLUS) && E() }

- å¯¹äºæ•´ä¸ªEæ¥è¯´ï¼š

  ```
  bool E() {
  	TOKEN *save = next;
  	return (next = save, E1()) || (next = save, E2());
  }
  ```



åŒæ ·çš„å¯¹äºä¸Šé¢çš„éç»ˆç»“ç¬¦Tï¼Œæœ‰ï¼š

```
bool T1() {
	return term(INT);
}

bool T2() {
	return term(INT) && term(TIMES) && T();
}

bool T3() {
	return term(OPEN) && E() && term(CLOSE);
}

bool T() {
 	TOKEN *save = next;
	return (next = save, T1()) || (next = save, T2() || (next = save, T3()));
}
```



æ•´ä¸ªæ­¥éª¤ï¼š

- åˆå§‹åŒ–nextä¸ºç¬¬ä¸€ä¸ªtoken
- è°ƒç”¨E()

**Conslusion**:

é€’å½’ä¸‹é™è¿‡ç¨‹ä¸­ï¼Œä¸æ–­åœ°é€’å½’åˆå›æº¯æ‰€äº§ç”Ÿçš„å‡½æ•°è°ƒç”¨ç»“æ„å…¶å®å°±æ˜¯è§£ææ ‘çš„ä½“ç°ï¼Œæ‰€ä»¥åœ¨é€’å½’ä¸‹é™çš„åŒæ—¶æ„å»ºASTã€‚



### ä¸Šé¢çš„é€’å½’ä¸‹é™ç®—æ³•çš„é™åˆ¶ï¼š

å¯¹äºE -> T | T | T + Eï¼Œä¸€æ—¦é€’å½’åˆ°äº†Tï¼Œå¹¶ä¸”ä»ç»§ç»­å‘ä¸‹é€’å½’ï¼Œä¸€æ—¦ä¸ç¬¦åˆäº†ï¼Œåªä¼šåœ¨å½“å‰å±‚çº§å°è¯•å…¶ä»–çš„æ¨å¯¼å¼ï¼Œä½†æ˜¯ä¸ä¼šåŸºäºTçš„åŒå±‚çº§å»å°è¯•Tå’ŒT+E

æ‰€ä»¥ä¸Šé¢çš„æ™®é€šçš„é€’å½’ä¸‹é™åªé€‚ç”¨äºä¸€éƒ¨åˆ†è¯­æ³•ï¼Œå¯¹äºæœ‰äº›ä¸ç¬¦åˆçš„è¯­æ³•ï¼Œå¯ä»¥é‡‡ç”¨å·¦å› å­(left-factor)è¿›è¡Œæ”¹å†™ï¼š

### å·¦é€’å½’

è€ƒè™‘äº§ç”Ÿå¼ï¼šS -> S a

```
bool S1() { return S() && term()}
bool S() { return S1()}
```

å¦‚æœä½¿ç”¨é€’å½’ä¸‹é™ï¼Œä¼šäº§ç”Ÿå¦‚ä¸‹çš„è°ƒç”¨é“¾æ¡ï¼šS => S1 => S => S1 => ... 

è¿™å°±æ˜¯å·¦é€’å½’è¯­æ³•

ä»¥ä¸‹æ˜¯å·¦é€’å½’è¯­æ³•æ›´ä¸€èˆ¬çš„å®šä¹‰ï¼š
$$
S \mathop{\rightarrow}^+ S\alpha (+è¡¨ç¤ºè‡³å°‘æœ‰ä¸€æ¬¡æ¨å¯¼)
$$
å†çœ‹è¿™ä¸ªğŸŒ°ï¼š
$$
S \rightarrow S\alpha | \beta
$$
å°†ä¼šäº§ç”Ÿä»¥$\beta$  å¼€å¤´çš„ä¸”$\beta$ åé¢ç´§è·Ÿä»»æ„æ•°é‡(>=0)$\alpha$çš„å­—ç¬¦ä¸²ã€‚

æ—¢ç„¶å·²ç»çŸ¥é“äº†ä¼šäº§ç”Ÿä»€ä¹ˆæ ·çš„å­—ç¬¦ä¸²ï¼Œå¯ä»¥é€šè¿‡æŠŠæ–‡æ³•æ”¹å†™æˆå³é€’å½’é¿å…é€’å½’ä¸‹é™äº§ç”Ÿçš„å·¦é€’å½’é—®é¢˜ï¼š
$$
S \rightarrow \beta S' \\
S' \rightarrow \alpha S' | \epsilon
$$
Conclusionï¼š

ä¸€èˆ¬çš„é€’å½’ä¸‹é™æ˜¯ä»å·¦åˆ°å³è§£æï¼Œç”±äºè¯¥ç®—æ³•çš„æ€§è´¨ï¼Œé‡åˆ°åšé€’å½’æ–‡æ³•ä¼šå¯¼è‡´æ— ç©·é€’å½’ï¼›å¯ä»¥é€šè¿‡æŠŠå·¦é€’å½’æ–‡æ³•æ”¹æˆç‰¹æ®Š(è¿™é‡Œçš„å³é€’å½’æ–‡æ³•ä¹Ÿä»…ä»…é€‚ç”¨äºéƒ¨åˆ†è¯­æ³•)çš„å³é€’å½’æ–‡æ³•é¿å…è¿™ä¸ªé—®é¢˜ï¼Œå› ä¸ºè¿™ä¸ªæ—¶å€™éç»ˆç»“ç¬¦åœ¨æœ€å³è¾¹ï¼Œä¸ä¼šæœ‰å³è¾¹å­—ç¬¦å­˜åœ¨ä¸€ç›´é¥¥é¥¿(ä¸€ç›´è®¿é—®ä¸åˆ°)çš„ç°è±¡ã€‚



æ›´ä¸€èˆ¬çš„ï¼Œå¯ä»¥æ”¹å†™æˆå¦‚ä¸‹ç‰¹æ®Šçš„å³é€’å½’æ–‡æ³•ï¼š
$$
S' \rightarrow S\alpha_1 | ... | S\alpha_n | \beta_1|...|\beta_m
$$

$$
S \rightarrow \beta_1 S'| ... | \beta_m S' \\
S' \rightarrow \alpha_1 S' | ... | \alpha_nS' | \epsilon
$$

ä½†æ˜¯æœ‰äº›è¯­æ³•ï¼Œå¦‚ï¼š
$$
S \rightarrow A\alpha | \beta \\
A \rightarrow S \beta
$$
è¿™ä¸ªè¯­æ³•ä¹Ÿæ˜¯å·¦é€’å½’è¯­æ³•ï¼Œå†™æˆå¦‚ä¸‹å½¢å¼æ›´å¥½ç†è§£ï¼š
$$
S \mathop{\rightarrow}^+ S \beta \alpha
$$
å¯ä»¥é€šè¿‡å…¶ä»–æ–¹å¼æ¶ˆé™¤å·¦é€’å½’ã€‚



ç»§ç»­top-down

### é¢„æµ‹

Predicive Parsers like recursive-descent but parser can **"predict"** which production to use:

- By looking at the next few tokens
- No backtracking

Predicive Parsers accept LL(k) grammars (1st L: left 2 right, 2nd L: left-most derivation, k: k tokens look ahead)

åœ¨é€’å½’ä¸‹é™ç®—æ³•é‡Œï¼š

- æ¯ä¸€æ­¥ï¼Œæœ‰å¾ˆå¤šäº§ç”Ÿå¼å¯ä»¥ä½¿ç”¨ï¼Œå¦‚ï¼šE -> T | T | T + Eï¼Œå¯¹äºEï¼Œæœ‰3ç§é€‰æ‹©
- éœ€è¦é€šè¿‡å›æº¯æ’¤é”€bad choices



LL(1):

- é€šè¿‡æ”¹å†™æˆåˆé€‚çš„æ–‡æ³•ï¼ˆä¸€èˆ¬æ˜¯å·¦å› å­åˆ†è§£ï¼Œå·¦å› å­åˆ†è§£å¯ä»¥ç†è§£ä¸ºå…¬å…±å·¦å› å­æå–ï¼Œè¿™é‡Œçš„å› å­å€¼ç»ˆç»“ç¬¦ï¼‰æ¯ä¸€æ­¥ï¼Œä»…æœ‰ä¸€æ­¥é€‰æ‹©ï¼š

> Hint: å…¶å®å°±æ˜¯æ ¹æ®å½“å‰é¢„æµ‹å­—ç¬¦å†³å®šé€‰æ‹©ä½¿ç”¨å“ªä¸ªæ¨å¯¼å¼ï¼Œè€Œè¿™ä¸ªé¢„æµ‹å­—ç¬¦å’Œæ¨å¯¼å¼çš„å…³ç³»éœ€è¦ç”¨ä¸€å¼ è¡¨æ¥è®°å½•

ç»§ç»­è€ƒè™‘è¯­æ³•Grammar: 

E -> T | T | T + E

T -> int | int * T | (E)

éš¾ä»¥äº§ç”Ÿé¢„æµ‹å­—ç¬¦ï¼š

- å¯¹äºTï¼Œæœ‰ä¸¤ä¸ªintå¼€å¤´çš„æ¨å¯¼å¼ï¼Œæ‰€ä»¥å³ä½¿å½“å‰æœ‰é¢„æµ‹å­—ç¬¦intï¼Œä¹Ÿæ— æ³•é€‰æ‹©å“ªä¸€ä¸ªæ˜¯æœ€ä¼˜çš„æ¨å¯¼
- å¯¹äºEï¼Œæ›´ä¸å®¹æ˜“çœ‹å‡ºé¢„æµ‹å­—ç¬¦æ˜¯ä»€ä¹ˆ

éœ€è¦å·¦å› å­è¯­æ³•æ”¹å†™ï¼š

E -> TX

X -> +E | \epsilon

T -> intY | (E)

Y -> *T | \epsilon



æ ¹æ®æ–°è¯­æ³•å¯ä»¥è®¡ç®—å¾—åˆ°LL(1) parse table: å…¶ä¸­è¡¨å¤´ä¸ºä¸‹ä¸€ä¸ªè¾“å…¥çš„tokenï¼Œæ¯ä¸€è¡Œæ˜¯éç»ˆç»“ç¬¦ï¼Œå•å…ƒæ ¼é‡Œçš„å†…å®¹å°±æ˜¯å½“å‰ä½¿ç”¨å“ªä¸ªæ¨å¯¼å¼çš„rfsï¼Œè¿™é‡Œæš‚æ—¶æ²¡æœ‰è®²å¦‚ä½•æ„é€ è¿™å¼ è¡¨çš„

|      | int   | *    | +          | ï¼ˆ   | ï¼‰         | $          |
| ---- | ----- | ---- | ---------- | ---- | ---------- | ---------- |
| E    | TX    |      |            | TX   |            |            |
| X    |       |      | +E         |      | $\epsilon$ | $\epsilon$ |
| T    | int Y |      |            | (E)  |            |            |
| Y    |       | *T   | $\epsilon$ |      | $\epsilon$ | $\epsilon$ |

æ¯”å¦‚ï¼š[Y, +] entryï¼Œè¡¨ç¤ºå½“å‰éç»ˆç»“ç¬¦Yï¼Œé‡åˆ°äº†å½“å‰è¾“å…¥token +

é‚£ä¹ˆYå°±å¯ä»¥æŒ‰ç…§$Y \rightarrow \epsilon$ æ¨å¯¼ï¼Œ

[E, *] entryï¼Œè¡¨ç¤ºå½“å‰éç»ˆç»“ç¬¦Xï¼Œé‡åˆ°äº†å½“å‰è¾“å…¥token *ï¼Œæ²¡æœ‰åˆé€‚çš„æ¨å¯¼å¼å¯ä»¥ä½¿ç”¨



è¿™é‡Œæˆ‘ä»¬å†æä¸€ä¸ªé¢å¤–çš„çŸ¥è¯†ç‚¹ï¼š

æˆ‘ä»¬ä¸æƒ³é‡‡ç”¨é€’å½’çš„æ–¹å¼å»åšè§£æï¼Œè€Œæ˜¯åˆ©ç”¨æ ˆè§£æï¼š

- éç»ˆç»“ç¬¦ä»ç„¶æ˜¯æ‰©å±•æ›¿æ¢çš„
- ç»ˆç»“ç¬¦ä¹Ÿä»ç„¶ä¼šè¾“å…¥è¿›è¡Œæ¯”è¾ƒåŒ¹é…
- æ ˆé¡¶=æœ€å·¦è¾¹çš„å¾…å¤„ç†çš„éç»ˆç»“ç¬¦æˆ–éç»ˆç»“ç¬¦
- Reject on reaching error state
- Accepy on end of input & empty stack



å½¢å¼åŒ–å®šä¹‰å¦‚ä¸‹ï¼š

```
initialize stack = <S $> and next
repeat
	case stack of
		<X, rest>: if T[X, *next] = Y1...Yn
								then stack <- <Y1...Yn rest>;
								else error(); // ä¸å­˜åœ¨æ¨å¯¼åŠ¨ä½œåˆ™ç›´æ¥æŠ¥é”™
		<t, rest>: if t == *next++
								then stack <- <rest>;
								else error();	
until stack == <>

åˆå§‹åŒ–çš„æ—¶å€™æ ˆé¡¶æ˜¯å…¶å®éç»ˆç»“ç¬¦S,
åç»­ï¼Œå¦‚æœå½“å‰æ ˆé¡¶æ˜¯éç»ˆç»“ç¬¦Xï¼Œä¸”æ ¹æ®é¢„æµ‹è¡¨æ‰§è¡Œçš„æ¨å¯¼åŠ¨ä½œæ˜¯X -> Y1...Yn,åˆ™pop X from stack and push Y1...Yn into stack
	å¦åˆ™ï¼šå¦‚æœæ ˆé¡¶æ˜¯ç»ˆç»“ç¬¦ä¸”å’Œå½“å‰è¾“å…¥ç›¸åŒï¼ˆè¯´æ˜æ ˆé¡¶çš„è¿™ä¸ªå…ƒç´ ç›´æ¥å¯ä»¥ä½¿ç”¨å…¶æœ¬èº«è¿›è¡Œæ¨å¯¼ï¼‰ï¼Œåˆ™pop t from stack
```

çœ‹ä¸€ä¸ªğŸŒ°ï¼š

![image-20230619230522565](/Users/bytedance/Library/Application Support/typora-user-images/image-20230619230522565.png)



### first



### follow



### ll1-parse-table

æ„å»ºé¢„æµ‹è¡¨çš„æ­¥éª¤ï¼š

For each production $A \rightarrow \alpha$ in G do:

- For each terminal $t \in First(\alpha)$ do
  - $T[A, t] = \alpha$
- If $\epsilon \in First(\alpha)$ for each t $t \in Follow(A) $ do
  - $T[A, t] = \alpha$
- If $\epsilon \in First(\alpha)$ and t $\$ \in Follow(A) $ do
  - $T[A, t] = \alpha$

First() = { $, ) }

Follow(X) = { +, $, ) }

æ‰€ä»¥ä¸Šé¢çš„è¯­æ³•å½¢æˆçš„é¢„æµ‹è¡¨å¦‚ä¸‹

|      | (    | )          | +          | *    | int  | $          |
| ---- | ---- | ---------- | ---------- | ---- | ---- | ---------- |
| E    | TX   |            |            |      | TX   |            |
| T    | (E)  |            |            |      | intY |            |
| X    |      | +E         |            |      |      | $\epsilon$ |
| Y    |      | $\epsilon$ | $\epsilon$ | *T   |      | $\epsilon$ |

ä¸Šè¿°è¡¨æ ¼æ¯ä¸ªè¡¨æ ¼å†…çš„æ¡ç›®æœ€å¤šåªæœ‰ä¸€æ¡ï¼Œå½“å”¯æçš„æ—¶å€™ï¼Œè¡¨ç¤ºè§£æé‡åˆ°é”™è¯¯ï¼Œä¸‹é¢çœ‹ä¸€ä¸ªè¡¨æ ¼å†…ä¸æ­¢ä¸€ä¸ªæ¡ç›®çš„ä¾‹å­ï¼š

è¯­æ³•ï¼š$S -> Sa | b$

First(S) = { b }

Follow(S) = { $, a }

|      | a      | b    | $    |
| ---- | ------ | ---- | ---- |
| $    | b / Sa |      |      |



æ­£å¦‚ä¸Šé¢çš„ä¾‹å­ï¼Œå¦‚æœä¸€ä¸ªè¡¨çš„å†…å®¹æ˜¯å¤šä¸ªï¼Œåˆ™è¯¥è¯­æ³•ä¸æ˜¯LL(1)ï¼Œå½“ç‡ƒåˆ¤æ–­æ˜¯å¦ä¸ºLL(1)è¿˜æœ‰å…¶ä»–æ–¹æ³•ï¼š

- éå·¦å› å­è¯­æ³•ä¸æ˜¯LL(1)
- å·¦é€’å½’ä¸æ˜¯LL(1)
- äºŒä¹‰æ€§ä¹Ÿä¸æ˜¯
- å…¶ä»–çš„ï¼Œå¦‚LL(k), k > 1ä¹Ÿä¸æ˜¯







**ç½‘é¡µçŸ¥è¯†ç‚¹ï¼š**

LLå’ŒLRï¼š

æ¦‚å¿µæ¢³ç†ï¼š

é¦–å…ˆè¯´æ˜ï¼ŒContext-free grammarä¸æ— äºŒä¹‰æ€§æ–‡æ³•ä¸æ˜¯ä¸€ä¸ªå±‚çº§çš„æ¦‚å¿µã€‚CFGçš„æ„æ€æ˜¯ï¼šæˆ‘ä»¬ç”¨äº§ç”Ÿå¼è®¾è®¡çš„ä¸€ç»„æ–‡æ³•ï¼Œå¯¹äºæ¯ä¸€ä¸ªæ¨å¯¼ï¼Œå…¶ä¸­çš„NTå¯ä»¥ä»»æ„åœ°è¢«äº§ç”Ÿå¼å³éƒ¨æ›¿æ¢è€Œåˆæ³•ï¼ˆè¿™å¹¶ä¸é™åˆ¶å¯¹äºä¸€ä¸ªæ–‡æœ¬ï¼Œåªèƒ½æ¨ç†å‡ºä¸€æ£µæ ‘ï¼‰ã€‚ä¹Ÿå°±æ˜¯æ¯ä¸ªNTä¹‹ä¸‹çš„äº§ç”Ÿå¼æ˜¯ç­‰ä»·çš„ï¼Œæ¯”å¦‚å¯¹äºVerb->åƒ/ç¡/é£ï¼Œåœ¨å…·ä½“è§£ææ—¶ï¼Œä¸è®ºå‰é¢çš„ä¸»è¯­/åé¢çš„å®¾è¯­æ˜¯ä»€ä¹ˆï¼Œéƒ½åˆæ³•ã€‚äºŒä¹‰æ€§æ˜¯åœ¨CFGä¹‹ä¸‹çš„æ¦‚å¿µã€‚



[LL and LR Parsing Demystified (reverberate.org)](https://blog.reverberate.org/2013/07/ll-and-lr-parsing-demystified.html)

LLè¡¨ç¤ºä»å·¦åˆ°å³æ‰«æè¾“å…¥å¹¶æ‰§è¡Œæœ€å·¦æ¨å¯¼ï¼ŒLLå’ŒLRç›¸æ¯”å“ªä¸ªé€‚ç”¨èŒƒå›´æ›´å¹¿å‘¢ï¼Ÿ

ä¸ºç®€å•è®¨è®ºï¼Œæˆ‘ä»¬åªè®¨è®ºLL(1)å’ŒLR(1)ï¼Œ1ä»£è¡¨å‘å‰æŸ¥çœ‹çš„å­—ç¬¦æ•°é‡ï¼ˆé¢„æµ‹1ä¸ªå­—ç¬¦ï¼‰ï¼Œ1è¡¨ç¤ºä»»ä½•æ—¶åˆ»æˆ‘ä»¬æå‰æŸ¥çœ‹å½“å‰è¾“å…¥å­—ç¬¦çš„ä¸‹ä¸€ä¸ªå­—ç¬¦ï¼Œå†æ ¹æ®è¿™ä¸ªæå‰æŸ¥çœ‹çš„å­—ç¬¦å†³å®šä½¿ç”¨å“ªä¸€ä¸ªè§„çº¦è¡Œä¸ºã€‚

- In LL(1) we see the first symbol of the input and see the production to apply. So, if there is two productions with the same â€˜firstâ€™ symbol as in the input parser gets a conflict and fails.
- åœ¨LL(1)é‡Œï¼Œæˆ‘ä»¬è‡ªå·¦åˆ°å³è¿›è¡Œè§„çº¦ï¼ŒæŸ¥çœ‹å½“å‰å­—ç¬¦å’Œé‡‡ç”¨å¯¹åº”çš„æ¨å¯¼å¼è¿›è¡Œè§„çº¦ã€‚æ‰€ä»¥ï¼Œå¦‚æœå¦‚æœæœ‰ä¸¤ä¸ªæ¨å¯¼å¼æœ‰ç€ç›¸åŒçš„fiest symbolï¼Œå°±ä¼šäº§ç”Ÿå†²çª
- åœ¨ LRï¼ˆ1ï¼‰ ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°ä»å·¦è¾¹å¼€å§‹çš„è¾“å…¥ï¼Œç›´åˆ°æˆ‘ä»¬å¾—åˆ°ä¸€ä¸ªhandleã€‚åœ¨æ­¤ä¹‹åï¼Œæˆ‘ä»¬å†çœ‹åˆ°ä¸€ä¸ªå‰ç»ç¬¦å·å¹¶ç¡®å®šè§£æå™¨æ“ä½œ.å³ï¼Œè§£æå™¨æ¯” LLï¼ˆ1ï¼‰ ä¸­æœ‰æ›´å¤šçš„ä¿¡æ¯æ¥å†³å®šå…¶æ“ä½œï¼Œè¿™ä½¿å¾—å®ƒæ¯” LLï¼ˆ1ï¼‰ æ›´å¼ºå¤§ã€‚æ›´å¼ºå¤§çš„æ‰‹æ®µæ˜¯ï¼Œä»»ä½•å¯ä»¥è¢« LLï¼ˆ1ï¼‰ è§£æçš„è¯­æ³•ä¹Ÿå¯ä»¥è¢« LRï¼ˆ1ï¼‰ è§£æã€‚
- è¿™ç§æƒ…å†µåœ¨æ›´ä¸€èˆ¬çš„åœºæ™¯ä¸‹ä¹Ÿæˆç«‹ï¼Œå¯¹äºä»»ä½•kï¼ŒLLï¼ˆkï¼‰è¯­æ³•é›†æ˜¯LRï¼ˆkï¼‰è¯­æ³•é›†çš„é€‚å½“å­é›†



è¿™é‡Œæˆ‘ä»¬æ‰€è¯´çš„è§£æå™¨çš„èƒ½åŠ›æŒ‡çš„æ˜¯å…¶å¯ä»¥è§£æçš„è¯­æ³•çš„èŒƒå›´ï¼Œå¹¶ä¸æ˜¯è¯´å®ƒèƒ½å¤Ÿç”Ÿæˆçš„è¯­è¨€ã€‚æ‰€ä»¥ä»€ä¹ˆæ˜¯LL(1)è¯­è¨€å‘¢ï¼Œå®ƒä»¬æ˜¯ä¸æ˜¯éƒ½å¯ä»¥è¢«LL(1)ç”Ÿæˆå‘¢ï¼Ÿ



å®é™…ä¸ŠLL(k)çš„èƒ½åŠ›å’Œkæˆæ­£æ¯”ï¼Œkè¶Šå¤§ï¼ŒLL(k)çš„èƒ½åŠ›è¶Šå¼ºï¼ŒLL(k)æ˜¯LL(k+1)çš„å­é›†



é‚£LR(k)?



$First(\alpha)$ æ˜¯ä»$\alpha$æ¨å¯¼çš„handleçš„èµ·å§‹ç»ˆç»“ç¬¦çš„é›†åˆ

$Follow(A)$(è¿™é‡Œå¤§å†™è¡¨ç¤ºAæ˜¯ä¸€ä¸ªéç»ˆç»“ç¬¦)ï¼Œæ˜¯ç´§è·Ÿåœ¨Aåé¢çš„ç»ˆç»“ç¬¦çš„é›†åˆ



å½“ä¸”ä»…å½“ä¸€ä¸ªè¯­æ³•Gæ»¡è¶³å¦‚ä¸‹æ¡ä»¶ï¼ŒGæ‰è¢«ç§°ä¹‹ä¸ºLL(1):

1. G not unambiluous
2. G not left-recursive
3. If there is a production $Aâ†’\alpha | \beta$, then
   1. $First(\alpha) \cup First(\beta) = empty$ å¦åˆ™è§£æå™¨ä¸çŸ¥é“ä½¿ç”¨å“ªä¸ªæ¨å¯¼å¼
   2. if $First(\alpha) \cup First(\beta) = empty$ contains $\epsilon$, $First(\beta)$ä¸åº”è¯¥åŒ…å«$\epsilon$, å¦åˆ™è§£æå™¨ä¸çŸ¥é“ä½¿ç”¨å“ªä¸ªæ¨å¯¼å¼
   3. if $First(\alpha) \cup First(\beta) = empty$, $First(\beta) \cup First(\alpha) = empty$, å¦åˆ™è§£æå™¨ä¸çŸ¥é“ä½¿ç”¨å“ªä¸ªæ¨å¯¼å¼



ä¸‹é¢æ˜¯LRéƒ¨åˆ†:



itemï¼šæ–‡æ³•çš„ä¸€ä¸ªäº§ç”Ÿå¼GåŠ ä¸Šå…¶å³éƒ¨æŸä¸€ä½ç½®çš„ä¸€ä¸ªç‚¹ï¼Œè¿™ä¸ªç‚¹è¡¨ç¤ºäº†åˆ†æè¿‡ç¨‹ä¸­çš„çŠ¶æ€ã€‚

äº§ç”Ÿå¼A->XYZ äº§ç”Ÿçš„å››ä¸ªé¡¹ï¼š

A->Â·XYZ
A->XÂ·YZ
A->XYÂ·Z
A->XYZÂ·
ä»¥ç¬¬äºŒä¸ªé¡¹ä¸ºä¾‹ï¼Œå…¶è¡¨ç¤ºå·²ç»æ¥æ”¶äº†ä¸€ä¸ªå¯ä»¥ç”±Xæ¨å¯¼çš„ä¸²ï¼Œå¦‚æœå¸Œæœ›èƒ½å½’çº¦ï¼Œé‚£ä¹ˆæ¥ä¸‹æ¥è¦è¯†åˆ«ä¸€ä¸ªèƒ½å¤Ÿç”±YZæ¨å¯¼çš„ä¸²ã€‚

Dcfl is a superset of regular. But dcfl with prefix property is not.



# Viable Prefixes and Handle in LR Parsing

### Bottom-up Parsing

Consider the grammar

- $S -> XX$
- $X -> aX | b $

Now, consider a string in $L(S)$ say aabb. We can parse it as follows by left most derivation â€“ replacing the left most non-terminal in each step, or right most derivation â€“ replacing the rightmost non-terminal in each step.

è€ƒè™‘ä¸€ä¸ªç¬¦åˆè¯¥æ–‡æ³•çš„å­—ç¬¦ä¸²aabbï¼Œæˆ‘ä»¬å¯ä»¥æŒ‰ç…§æœ€å·¦æ¨å¯¼è§£æå®ƒï¼ˆæ¯ä¸€æ­¥æ›¿æ¢æœ€å·¦è¾¹çš„éç»ˆç»“ç¬¦ï¼‰æˆ–è€…ä¹Ÿå¯ä»¥æŒ‰ç…§æœ€å³æ¨å¯¼è§£æå®ƒï¼ˆæ¯ä¸€æ­¥æ›¿æ¢æœ€å³è¾¹çš„éç»ˆç»“ç¬¦ï¼‰

![image-20230619000054295](/Users/bytedance/Library/Application Support/typora-user-images/image-20230619000054295.png)

**ä¸Šé¢çš„æœ€å³æ¨å¯¼è¢«ç”¨åœ¨bottom-up parsing**

> - *Any string derivable from the start symbol is a sentential form â€” it becomes a sentence if it contains only terminals*
> - *A sentential form that occurs in the leftmost derivation of some sentence is called left-sentential form*
> - *A sentential form that occurs in the rightmost derivation of some sentence is called right-sentential form*



å†æ¬¡è€ƒè™‘å­—ç¬¦ä¸²aabbï¼Œæˆ‘ä»¬å¯ä»¥æŒ‰ç…§å¦‚ä¸‹æ–¹æ³•è§£æï¼š

ä»å·¦è‡³å³æ‰«æè¾“å…¥ï¼Œå¦‚æœå­˜åœ¨å­ä¸²åŒ¹é…ä»»ä½•æ¨å¯¼å¼çš„**å³ä¾§**(RHS, right hand of string), ç”¨è¯¥æ¨å¯¼å¼çš„**å·¦ä¾§**æ›¿æ¢è¯¥å­—ç¬¦ä¸²

å…·ä½“æ­¥éª¤å¦‚ä¸‹ï¼š

1. â€˜aâ€™ â€œabbâ€ â€“ ä¸å­˜åœ¨RHSåŒ¹é…'a'
2. â€˜aaâ€™ â€œbbâ€ â€“ ä¸å­˜åœ¨RHSåŒ¹é…'a' æˆ–è€… 'aa'
3. â€˜aabâ€™ â€œbâ€ â€“ RHS of $Xâ†’b$ matches â€˜bâ€™ (first b from left) and so we write as



Consider the string aabb again. We will see a method to parse this:

1. Scan the input from left to right and see if any substring matches the RHS of any production. If so, replace that substring by the LHS of the production.

So, for â€œaabbâ€ we do as follows

1. â€˜aâ€™ â€œabbâ€ â€“ No RHS matches â€˜aâ€™
2. â€˜aaâ€™ â€œbbâ€ â€“ No RHS matches â€˜aâ€™ or â€˜aaâ€™
3. â€˜aabâ€™ â€œbâ€ â€“ RHS of $Xâ†’b$ matches â€˜bâ€™ (first b from left) and so we write as aaXb
4. â€˜aaXâ€™ â€œbâ€ â€“ RHS of $Xâ†’aX$ matches â€œaXâ€ and so we write as
5. aXb â€“ Again RHS of $Xâ†’aX$ matches â€œaXâ€ and we get
6. Xb â€“ RHS of $Xâ†’b$ matches â€œbâ€ and we get
7. XX â€“ RHS of $Sâ†’XX$matches XX and we get
8. S â€“ the start symbol.



Now what we did here is nothing but a bottom-up parsing. Bottom-up because we started from the string and not from the grammar. Here, we applied a sequence of reductions, which are as follows:
$$
aabb â†’ aaXb â†’ aXb â†’ Xb â†’ XX â†’ S
$$
If we go up and see the Rightmost derivation of the string â€œaabbâ€, what we got is the same but in REVERSE order. i.e., our bottom up parsing is doing reverse of the RIGHTMOST derivation(ä»”ç»†è§‚å¯Ÿä¸Šè¿°çš„æ›¿æ¢è¿‡ç¨‹å’Œæœ€å¼€å§‹çš„æœ€å³æ¨å¯¼çš„é¡ºåºæ˜¯ç›¸åçš„). **So, we can call it an $LR$ parser â€“$ L$ for scanning the input from Left side and $R$ for doing a Rightmost derivation.**

In our parsing we substituted the RHS of a production at each step. This substituted â€œsubstringâ€ is called a HANDLE and are shown in **BOLD** below(åœ¨æ¨å¯¼è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬åœ¨æ¯ä¸€æ­¥æ›¿æ¢äº†å­ä¸²ï¼Œè¿™äº›å­ä¸²ç§°ä¸ºHandleï¼Œåœ¨ä¸‹é¢è¢«åŠ ç²—äº†).
$$
aa\bold bb â†’ a\bold a \bold Xb â†’ \bold a \bold Xb â†’ X\bold b â†’ \bold X \bold X â†’ S
$$
Formally a handle is defined as (Greek letters used to denote a string of terminals and non-terminals)

> "*A handle of a right sentential form â€˜*Î³*â€™* (Î³=Î±Î´Î²*) is a production* Eâ†’Î´ *and a position in* Î³ *where* Î´ *can be found and substituted by* E *to get the* **previous step** *in the right most derivation of* Î³ *â€” previous and not â€œnextâ€ because we are doing rightmost derivation in REVERSE. Handle can be given as a production or just the RHS of a production.*

The handle is not necessarily starting from the left most position as clear from the above example (ä»ä¸Šé¢çš„ä¾‹å­å¯ä»¥çœ‹åˆ°handleä¸ä¸€å®šå¼€å§‹äºRHSçš„æœ€å·¦è¾¹). There is importance to the input string which occurs to the left of the handle (æ‰€è°“çš„å¯è¡Œå‰ç¼€å°±æ˜¯å½“å‰handleçš„æ‰€æœ‰å‰ç¼€). For example for the handles of â€œaabbâ€, we can have the following set of prefixes

|          |              |
| -------- | ------------ |
| aa**b**b | {a, aa, aab} |
| aa**X**b | {a, aa, aaX} |
| a**X**b  | {a, aX}      |
| X**b**   | {X, Xb}      |
| **XX**   | {X, XX}      |

These set of prefixes are called Viable Prefixes (è¿™äº›å‰ç¼€é›†åˆè¢«ç§°ä¸ºå¯è¡Œå‰ç¼€). Formally

> " Viable prefixes are the prefixes of right sentential forms that do not extend beyond the end of its handle.
>
> i.e., a viable prefix either has no handle or just one possible handle on the extreme RIGHT which can be reduced.

We will see later that viable prefixes can also be defined as the set of prefixes of the right-sentential form that can appear on the stack of a shift-reduce parser. Also, the set of all viable prefixes of the right sentential forms of a grammar is a REGULAR LANGUAGE. i.e., viable prefixes can be recognized by using a FINITE AUTOMATA. Using this FINITE AUTOMATA and a stack we get the power of a Push Down Automata and that is how we can parse context-free languages.

åœ¨åé¢ï¼Œå¯è¡Œå‰ç¼€ä¹Ÿå¯ä»¥è¢«å®šä¹‰ä¸ºå‡ºç°åœ¨shift-reduceè§£æå™¨çš„æœ€å³æ¨å¯¼å¼çš„å‰ç¼€é›†åˆã€‚å½“ç„¶ï¼Œæ‰€æœ‰çš„å¯è¡Œå‰ç¼€æ˜¯æ­£åˆ™è¯­è¨€ï¼Œæ‰€ä»¥ï¼Œå¯è¡Œå‰ç¼€å¯ä»¥è¢«æœ‰é™è‡ªåŠ¨æœºè¯†åˆ«ã€‚ä½¿ç”¨æœ‰é™è‡ªåŠ¨æœºå’Œstackå°±å¯ä»¥Push Down Automataï¼Œè¿™æœ¬è´¨ä¸Šå°±æ˜¯åœ¨è§£æä¸Šä¸‹æ— å…³æ–‡æ³•ã€‚



**å‚è€ƒæ–‡çŒ®**ï¼šhttps://web.stanford.edu/class/archive/cs/cs143/cs143.1128/handouts/100%20Bottom-Up%20Parsing.pdf
