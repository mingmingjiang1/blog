---
title: æ–¯å¦ç¦cs231(ç¼–è¯‘åŸç†)ã® 5 Semantic Analysis
date: 2023-06-04 13:53:15
tags: ç¼–è¯‘åŸç†ï¼Œè®¡ç®—æœºåŸºç¡€ï¼Œcool
math: true
categories: ç¼–è¯‘åŸç†
---

## **Type Checking Rules and How to Implement ?**

Cool type can be implemented in a single traversal over the AST

- Type environment is passed down the tree (From parent to child)ï¼Œç¯å¢ƒè‡ªä¸Šè€Œä¸‹æ˜¯åœ¨ä¸æ–­æ‰©å¢çš„
- Types are passed up the tree from (From child to parent)ï¼Œç±»å‹æ˜¯è‡ªåº•å‘ä¸Šæ¨å¯¼å’Œæ£€æŸ¥çš„



ğŸŒ°ï¼š
$$
\frac{O,M,C\vdash e_1:Int \quad O,M,C\vdash e_2:Int }{O,M,C\vdash e_1 + e_2:Int }
$$


> Environment(Object, Method, Class), ç¯å¢ƒåŒ…æ‹¬å½“å‰å¯¹è±¡ï¼Œå½“å‰æ–¹æ³•åŠå½“å‰ç±»

```
TypeCheck(Envirment, e1 + e2) = {
	T1 = TypeCheck(Envirment, e1)
	T2 = TypeCheck(Envirment, e2)
	check T1 == T2 == Int
	return Int
}
```



ğŸŒ°ï¼š
$$
\begin{equation}
\begin{aligned}
\frac{
O,M,C\vdash e_0:T_0 \quad
O[T/x],M,C\vdash e_1:T_1  \quad
T_0 <= T}{O,M,C\vdash e_1 + e_2:Int }
\end{aligned}
\end{equation}
$$


```
TypeCheck(Envirment, let x: T <- e0 in e1) = {
	T0 = TypeCheck(Envirment, e0)
	T1 = TypeCheck(Envirment.add({x: T}), e1)
	check SubType(T0, T)
	return T1
}

è‡ªä¸Šè€Œä¸‹ï¼Œenvironmentä¸æ–­æ‰©å¢ï¼Œè‡ªåº•å‘ä¸Šæ£€æŸ¥ç±»å‹
```



## Introduction to Semantic Analysis

- Lexical analysis

  - Detects inputs with illegal tokens

- Parsing

  - Detects inputs with ill-formed parse trees

- Semantic analysis

  - Last. Front end phase
  - Catched all remaining errors

  

Why do semantic analysis ?

- Parsing can't catch some errors
- **Some langaguage constructs not context-free**

> [(2 å°ç§ä¿¡ / 25 æ¡æ¶ˆæ¯) åº”è¯¥å¦‚ä½•ç†è§£ã€Œä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•ã€ï¼Ÿ - çŸ¥ä¹ (zhihu.com)](https://www.zhihu.com/question/21833944)



Semantic analysis will do ?

- All identifiers are declared
- Type checking
- Inheritance relationships checking
- Classes defined ony once
- Methods in a class defined only once
- Reserved identifiers are not misused
- ...



## é™æ€ä½œç”¨åŸŸ

Matching static declarations with uses

- Important static analyisis step in most language
- including COOL



ğŸŒ°ï¼š

```
let y: String <- "abc" in y + 3 // åœ¨åé¢çš„è¯­å¥é‡Œyä¸ºstringç±»å‹

let y: Int in x + 3 // æ²¡æœ‰çœ‹åˆ°xçš„å®šä¹‰ï¼Œå°†ä¼šæŠ¥é”™
```

> The scope of an identifier is the portion of a program in which that identifier is accessible

è®¡ç®—æœºé¢†åŸŸé‡Œå˜é‡ä½œç”¨åŸŸæŒ‡çš„æ˜¯ç¨‹åºä¸­å˜é‡çš„èµ·ä½œç”¨(å¯ä»¥get)çš„ä¸€æ®µèŒƒå›´

ä¸åŒä½œç”¨åŸŸé‡Œå¯å­˜åœ¨åŒåå˜é‡ï¼ŒåŒä¸€ä¸ªä½œç”¨åŸŸä¸å¯å‡ºç°ä¸åŒåå˜é‡

ä¸€ä¸ªå˜é‡çš„ä½œç”¨åŸŸèŒƒå›´æ˜¯æœ‰é™çš„



è®¸å¤šè¯­è¨€éƒ½æ˜¯é™æ€ä½œç”¨åŸŸï¼š

ä½œç”¨åŸŸä»…ä»…ä¾èµ–ç¨‹åºæ–‡æœ¬ï¼Œæ ¹æ®å˜é‡åœ¨ç¨‹åºæ–‡æœ¬çš„ä½ç½®å†³å®šå˜é‡çš„ä½œç”¨åŸŸï¼Œæ²¡æœ‰ä»»ä½•è¿è¡Œæ—¶å†³å®šçš„è¡Œä¸ºï¼Œeg: Cool

åŠ¨æ€ä½œç”¨åŸŸï¼š

Lisp: Lisp has changed to mostly static scoping

Scope depends on execution of the program

ğŸŒ°ï¼š

```
let x: Int <- 0 in
	{
		x; =>>>>>> 1
		let x: Int <- 1 in
			x; =>>>> 2
		x; =>>>>>> 1
	}
	
ä¸Šé¢1å·xå’Œ2å·xæ˜¯ä¸åŒçš„ä½œç”¨åŸŸé‡Œx

åŠ¨æ€ä½œç”¨åŸŸé‡Œçš„å˜é‡æ€»æ˜¯æŒ‡å‘ç¦»å®ƒæœ€è¿‘çš„å˜é‡

g(y) = let a <- 4 in f(3);
f(x) = a =>>>>> a = 4
```



Cool identifier bindings are introduced by:

- Class declarations (introduce class names)
- Method declarations (introduce method names)
- Let declarations (introduce object id's)
- Formal declarations (introduce object id's)
- Attribute declarations (introduce object id's)
- Case declarations (introduce object id's)



Cool çš„æ ‡è¯†ç¬¦å¹¶ä¸éƒ½æ˜¯å…è®¸åµŒå¥—çš„

æ¯”å¦‚ç±»å®šä¹‰ä¸å…è®¸åµŒå¥—ï¼Œç±»åä½¿ç”¨å‰å¿…é¡»å®šä¹‰



## é™æ€ä½œç”¨åŸŸå®ç°ï¼ˆç¬¦å·è¡¨ï¼‰

Much of semantic analysis can be expressed as a recursive descent of on an AST

- Before: Process an AST node n
- Recurse: Process the children of n
- After: Finish processing the AST node n



When performing semantic analysis on a portion of the AST, we need to know which identifiers are defined

å½“åœ¨ASTçš„æŸéƒ¨åˆ†ä¸Šæ‰§è¡Œè¯­ä¹‰åˆ†ææ—¶ï¼Œéœ€è¦çŸ¥é“å“ªäº›æ ‡è¯†ç¬¦å·²ç»è¢«å®šä¹‰äº†ã€‚

```
let x: Int <- 0 in e

		let x(sym)

init = 0.(sym)     e(sym + x)

x is defined in subtree e
```

`Recall: let x: Int <- 0 in e`

Idea:

- Before processing e, add definition of x to current definitions, overriding any other definition of x
- Recurse
- After processing e, remove definition of x and restore old definition of x



a symbol table is a data structure that tracks the current bindings of identifiers



ç®€å•çš„å®ç°å¯ä»¥ä½¿ç”¨stack

- `Add_symbol(x)`
- `Find_symbol(x) search stack, starting from top fro x, return x or NULL if none found`
- `Remove() pop from ths stack`
- `exit_scope() exit current scope`
- `Check_scope(x) true if x defined in current scope`



åœ¨COOLé‡Œä½¿ç”¨stackå³å¯å¯¹letå£°æ˜çš„å˜é‡è¿›è¡Œå¤„ç†

æ¯æ¬¡ç”¨letå£°æ˜ä¸€ä¸ªå˜é‡ï¼Œå³pushå…¥stackï¼Œè€Œä¸”ä¹Ÿå…è®¸åµŒå¥—ï¼Œæ¯æ¬¡é€€å‡ºå½“å‰letèŒƒå›´ï¼Œå³popå‡ºå˜é‡ï¼›

ä½†æ˜¯å¯¹äºå‡½æ•°ç¡®ä¸å¥½ä½¿ç”¨ï¼Œæ¯”å¦‚å‡½æ•°å‚æ•°ï¼Œä¸€æ¬¡æœ‰å¤šä¸ªå‚æ•°ï¼Œå¹¶ä¸”æœ‰é‡åçš„å‚æ•°ï¼Œæ‰€ä»¥å¾—ä¸€æ¬¡pushå¤šä¸ªå˜é‡ï¼Œä½†æ˜¯å¤šä¸ªå˜é‡æ˜¯åœ¨åŒä¸€ä¸ªå±‚çº§é‡Œï¼Œè€Œstackçš„è§£å†³æ–¹æ¡ˆé»˜è®¤ä¸€ä¸ªå˜é‡ä¸€ä¸ªå±‚çº§



> class names can be used before being defined in COOL
>
> solutionï¼štwo passes to tranversal on AST
>
> - Pass1: Gather all class names
> - Pass2: Do the checking



## ç±»å‹

ä»€ä¹ˆæ˜¯ç±»å‹ï¼Œä¸åŒçš„è¯­è¨€å¯¹äºç±»å‹å®šä¹‰ä¸åŒï¼Œä½†é€šå¸¸æ„ä¹‰ä¸Šï¼Œä¸€è‡´è®¤ä¸ºè¢«å®šä¹‰å¦‚ä¸‹ï¼š

- ä¸€äº›å€¼çš„é›†åˆï¼ˆæ•°æ®ï¼‰
- å¯æ“ä½œè¿™äº›å€¼çš„ä¸€äº›æ“ä½œï¼ˆç®—æ³•/å‡½æ•°/æ–¹æ³•ï¼‰



å¿…é¡»ç¡®ä¿åœ¨è½¬åŒ–ä¸ºæœºå™¨è¯­è¨€ä¹‹å‰åšå¥½ç±»å‹æ£€æŸ¥å“¦ï¼Œå› ä¸ºæœºå™¨è¯­è¨€æ‰§è¡ŒæŒ‡ä»¤ä¸ä¼šåšä»»ä½•æ£€æŸ¥ã€‚è¯­è¨€ç±»å‹ç³»ç»ŸçŸ¥åé‡Œåœ¨å“ªäº›ç±»å‹ä¸Šçš„å“ªäº›æ“ä½œæ˜¯åˆæ³•çš„ã€‚è¯­è¨€çš„ç±»å‹æ£€æŸ¥ç›®çš„å°±æ˜¯ç¡®ä¿åœ¨æ­£ç¡®çš„ç±»å‹ä¸Šæ‰§è¡Œæ­£ç¡®çš„æ“ä½œã€‚

ç±»å‹æ£€æŸ¥æ—¶æœŸï¼š

- ç¼–è¯‘æ—¶æœŸæ‰§è¡Œç±»å‹æ£€æŸ¥ï¼šC, COOL, Java
- è¿è¡Œæ—¶ç±»å‹æ£€æŸ¥ï¼šç¨‹åºæ‰§è¡Œçš„æ—¶å€™æ‰§è¡Œç±»å‹æ£€æŸ¥, Python, Lisp, Perl
- æ— ç±»å‹æ£€æŸ¥ï¼šmachine code



é™æ€ç±»å‹æ£€æŸ¥ vs åŠ¨æ€ç±»å‹æ£€æŸ¥

- é™æ€æ£€æŸ¥å¯ä»¥åœ¨ç¼–è¯‘æ—¶æœŸæ•è·é”™è¯¯
- é¿å…è¿è¡Œæ—¶é”™è¯¯

åŠ¨æ€æ£€æŸ¥ï¼š

- é™æ€ç±»å‹æ£€æŸ¥æ˜¯æœ‰å±€é™æ€§çš„ï¼Œæœ‰äº›è¯­å¥åœ¨é™æ€ç±»å‹ä¸å¥½æ£€æŸ¥å‡ºæ¥ï¼Œæ¯”å¦‚ç»§æ‰¿çš„æ—¶å€™ï¼Œå­ç±»è°ƒç”¨çˆ¶ç±»çš„æ–¹æ³•



ç°ä»£ç¼–ç¨‹è¯­è¨€å¾ˆå¤šç»“åˆäº†ä¸¤è€…ï¼Œå¦‚ï¼š

Cï¼Œjavaå¯ä»¥ä½¿ç”¨unsafeé€ƒè„±é™æ€æ£€æŸ¥

People retrofit static typing to dynamically typed languages for debugging or optimization



ç±»å‹æ£€æŸ¥ï¼šéªŒè¯ç±»å‹çš„åˆæ³•æ€§

ç±»å‹æ¨æ–­ï¼šè‡ªåŠ¨æ¨æ–­å’Œå¡«å……ç¼ºå¤±çš„ç±»å‹ä¿¡æ¯



ä¹‹å‰å·²ç»è§è¿‡ä¸€äº›formal notionsï¼Œæ¯”å¦‚ï¼š

- Regular expressions
- Context-free grammars

ç±»å‹æ£€æŸ¥ä¹Ÿæœ‰ä¸€å¥—æ ‡å‡†çš„é€»è¾‘æ¨å¯¼è§„åˆ™ï¼š

æ¨å¯¼è§„åˆ™å…·æœ‰å¦‚ä¸‹å½¢å¼ï¼š

*If Hypothesis is true, then Conclusion is true*

ç±»å‹æ£€æŸ¥å°±æ˜¯é€šè¿‡è¿™æ ·çš„æ¨ç†ï¼š

*If E1 and E2 have certain types, then E3 has a certain type*

```
^ => and
=> if-then
x: T => x has type 'T'
```

> if e1 has type int and e2 type int, then e1 + e2 has type int  =======>
>
> e1 has type ^ e2 has type int  => e1 + e2 has type int =======>
>
> (E1: int ^ e2 : int) => e1 + e2: int

the statement `(E1: int ^ e2 : int) => e1 + e2: int` is a special case of `hypothesis1 ^ ... ^ hypothesisn => Conclusion `  

ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œä¸Šé¢çš„æ¨å¯¼è§„åˆ™å†™å‡ºå¦‚ä¸‹ç¬¦å·å½¢å¼ï¼š
$$
\frac{\vdash hypothesis1 \vdash hypothesis2 ... \vdash hypothesisn}{\vdash Conslusion}
$$
$\vdash$ means ''it is provable that ..."

çœ‹å‡ ä¸ªç®€å•çš„æ¨å¯¼è§„åˆ™ï¼š
$$
\frac{i \quad is \quad an \quad interger \quad literal}{\vdash i: int}
$$

$$
\frac{e1: int \quad e2: int}{\vdash e1 + e2: int}
$$

ç±»å‹æ£€æŸ¥å¯ä»¥å¾ˆå¥½çš„åŸºäºASTæ¥åšï¼š

å¦‚æœå·²ç»è¯æ˜äº†å­è¡¨è¾¾å¼çš„ç±»å‹ï¼Œé‚£ä¹ˆçˆ¶èŠ‚ç‚¹çš„ç±»å‹ä¹Ÿå°±å¾ˆå¥½åœ°å¾—åˆ°ï¼Œæ‰€ä»¥ç±»å‹æ£€æŸ¥å’Œæ¨æ–­æ˜¯è‡ªåº•å‘ä¸Šåšçš„





## ç±»å‹ç¯å¢ƒ

åœ¨ç±»å‹æ¨å¯¼/æ£€æŸ¥ä¸­ï¼Œæœ‰çš„æ—¶å€™ä¸€ä¸ªå˜é‡çš„ç±»å‹ä¿¡æ¯éœ€è¦æ›´å¤šçš„ä¿¡æ¯æ‰èƒ½è·å¾—è¯¥å˜é‡çš„ç±»å‹ï¼Œæ‰€ä»¥åœ¨æˆ‘ä»¬çš„æ¨å¯¼è§„åˆ™é‡Œéœ€è¦åŠ å…¥æ›´å¤šçš„ç±»å‹ä¿¡æ¯â€”â€”ç±»å‹ç¯å¢ƒï¼Œç±»å‹ç¯å¢ƒç»™äºˆäº†è‡ªç”±å˜é‡æ›´å¤šçš„ç›¸å…³ç±»å‹ä¿¡æ¯

ç±»å‹ç¯å¢ƒï¼ša fucntion from object identifiers to  Types (å³æ ‡è¯†ç¬¦åˆ°ç±»å‹çš„æ˜ å°„)

è‡ªç”±å˜é‡ï¼šå¦‚æœä¸€ä¸ªè¡¨è¾¾å¼é‡Œå­˜åœ¨ä¸€ä¸ªå˜é‡æ²¡æœ‰è¢«å®šä¹‰ï¼Œé‚£ä¹ˆè¯¥å˜é‡å°±æ˜¯è‡ªç”±å˜é‡

```
let y: int <- 0 in x + y
è¿™é‡Œleté™å®šä¸‹ï¼Œxæ˜¯æœªå®šä¹‰çš„ï¼Œè€Œyæ˜¯intç±»å‹ä¸”åˆå§‹åŒ–ä¸º0ï¼Œåœ¨è¿›è¡Œç±»å‹æ£€æŸ¥çš„æ—¶å€™ï¼Œæˆ‘ä»¬åªæœ‰æ‹¥æœ‰äº†å‰é¢å…³äºxçš„ä¿¡æ¯ï¼Œæ‰èƒ½çŸ¥é“xçš„ç±»å‹
```

let O be function from Object idenfiers to types, notion as follow:
$$
O\vdash e: T
$$
è¯»ä½œï¼šåœ¨ç¯å¢ƒOä¸‹ï¼Œå¯ä»¥è¯æ˜eæ˜¯Tç±»å‹

å•ç‚¹ä¿®æ”¹ï¼š
$$
\begin{equation}
\begin{aligned}
\frac{
O[T/x]\vdash e_1:int  \quad
}{O\vdash e_1 + e_2:Int }
\end{aligned}
\end{equation}
$$

```
è¡¨ç¤º
O[T/x](x) = int
O[T/x](y) = y (x != y)
```

å®é™…ä¸Šç±»å‹ç¯å¢ƒOå¯ä»¥ç”±ä¹‹å‰çš„Symbol tableå®ç°ï¼Œå› ä¸º

- ç±»å‹ç¯å¢ƒç»™äºˆå½“å‰ä½œç”¨åŸŸå†…éƒ¨æ ‡è¯†ç¬¦ç±»å‹ï¼ˆå’Œä½œç”¨åŸŸç±»å‹ï¼Œåªä¸è¿‡ä½œç”¨åŸŸæ˜¯è®°å½•æ ‡è¯†ç¬¦ï¼‰
- ç±»å‹ç¯å¢ƒä¹Ÿæ˜¯è‡ªä¸Šå‘ä¸‹ä¸æ–­æ‰©å¢å’Œå•ç‚¹ä¿®æ”¹
- ä½†æ˜¯ç±»å‹æ£€æŸ¥å’Œæ¨æ–­æ˜¯è‡ªåº•å‘ä¸Šçš„



## Subtypings

subtypings ä¸»è¦ç”¨äºç»§æ‰¿ç±»å‹1åˆ¤æ–­
$$
\begin{equation}
\begin{aligned}
\frac{
O\vdash e_0:T_0  \quad
O[T_0/x]\vdash e_1:T_1  \quad
}{O\vdash let \quad x: T_0 = e_0 \quad in \quad e_1: T_1 }
\end{aligned}
\end{equation}
$$
åœ¨ç±»ä¸Šå®šä¹‰å…³ç³»ï¼š<= 

- X <= Y
- X <= Y if X inherits from Y
- X <= Z if X <= Y and Y <= Z

$$
\begin{equation}
\begin{aligned}
\frac{
O\vdash e_0:T_0  \quad
O[T_0/x]\vdash e_1:T_1  \quad 
T_0 <= T
}{O\vdash let \quad x: T_0 = e_0 \quad in \quad e_1: T_1 }
\end{aligned}
\end{equation}
$$



å±æ€§åˆå§‹åŒ–ï¼š
$$
\begin{equation}
\begin{aligned}
\frac{
O_c(x) = T_0  \quad
O_C\vdash e_1:T_1  \quad 
T_1 <= T0
}{O\vdash x: T_0 = e_1 }
\end{aligned}
\end{equation}
$$


è€ƒè™‘ `if e0 then e1 else e2 fi`

è¡¨è¾¾å¼çš„ç»“æœè¦ä¹ˆe1è¦ä¹ˆe2ï¼Œå¯¹åº”çš„ç±»å‹è¦ä¹ˆæ˜¯e1çš„ç±»å‹è¦ä¹ˆæ˜¯e2çš„ç±»å‹

é‚£ä¹ˆæ•´ä¸ªif-elseè¡¨è¾¾å¼è¿”å›ä»€ä¹ˆç±»å‹ï¼Ÿ

æœ€å¥½çš„æ–¹æ³•æ˜¯è¿”å›e1å’Œe2çš„æœ€å°ä¸Šç•Œç±»å‹ï¼ˆleast upper typeï¼‰

least upper bound: lub(X, Y)ï¼Œè¡¨ç¤ºXå’ŒYçš„æœ€å°ä¸Šç•Œç±»å‹ï¼Œ

if X <= Z ^ Y <= Z: Z is an upper bound

If X <= Z' ^ Y <= Z', Z <= Z': Z is an upper bound

COOLé‡Œï¼Œä¸¤ä¸ªç±»å‹çš„æœ€å°ä¸Šç•Œæ˜¯å®ƒä»¬ç»§æ‰¿æ ‘é‡Œæœ€è¿‘å…¬å…±ç¥–å…ˆ


$$
\begin{equation}
\begin{aligned}
\frac{
O\vdash e_0:Bool  \quad
O\vdash e_1:T_1  \quad 
O\vdash e_1:T_2  \quad 
}{O\vdash if \quad e_0 \quad then \quad e_1 \quad else \quad e_2 \quad fi \quad fi: lub(T_1, T_2) }
\end{aligned}
\end{equation}
$$


## Typing Methods

$$
dispatch:
\begin{equation}
\begin{aligned}
\frac{
O\vdash e_0:T_0  \quad
O\vdash e_1:T_1  \quad 
... \quad
O\vdash e_n:T_n  \quad 
}{O\vdash e_0.f(e_1, ... e_n): ? }
\end{aligned}
\end{equation}
$$

ä¸çŸ¥é“ä»»ä½•å…³äºfçš„ä¿¡æ¯ï¼Œå¦‚ä½•çŸ¥é“fçš„è¿”å›å€¼ç±»å‹ï¼Ÿ

In cool, method and object identifiers live in different name spaces

- A method foo and an object foo can coexisted in the same scope



In the type rules, this is reflected by a seperate mapping M for method signatures
$$
M(C, f) = (T_1, ... T_n, T_{n+1}) means \quad in \quad Class \quad C \quad there \quad is \quad \\ a \quad method \\ f: \quad
f(x_1: T_1, ... x_n: T_n): T_{n+1}
$$


dispatch
$$
dispatch:
\begin{equation}
\begin{aligned}
\frac{
O\vdash e_0:T_0  \quad
O\vdash e_1:T_1  \quad 
... \quad
O\vdash e_n:T_n  \quad 
T_i <= T_{i'} 1 <= i <= n \quad
M(T_0, f) = (T_{1'}, ... T_{n'}, T_{n+1})
}{O\vdash e_0.f(e_1, ... e_n): T_{n+1} }
\end{aligned}
\end{equation}
$$


é™æ€dispatch
$$
static dispatch:
\begin{equation}
\begin{aligned}
\frac{
O\vdash e_0:T_0  \quad
O\vdash e_1:T_1  \quad 
... \quad
O\vdash e_n:T_n  \quad 
T_0 <= T \quad
T_i <= T_{i'} 1 <= i <= n \quad
M(T_0, f) = (T_{1'}, ... T_{n'}, T_{n+1})
}{O\vdash e_0@T.f(e_1, ... e_n): T_{n+1} }
\end{aligned}
\end{equation}
$$
æœ€ç»ˆç»“åˆæ–¹æ³•ç¯å¢ƒï¼Œå˜é‡ç¯å¢ƒå’Œç±»ï¼Œ
$$
\begin{equation}
\begin{aligned}
\frac{
O, M, C\vdash e_1:int  \quad 
O, M, C\vdash e_2:int  \quad 
}{O, M, C\vdash e1 + e2: int }
\end{aligned}
\end{equation}
$$
ä¸Šé¢çš„è§„åˆ™ä»…é€‚ç”¨äºCOOL

> General themes:
>
> - Type rules are defined on the structure of expressions
> - Types of varaibles are modeled by an environment



## Static Type vs Dynamic Type

é™æ€ç±»å‹æ£€æŸ¥ï¼š

å¯ä»¥åœ¨ç¼–è¯‘æ—¶æœŸå‘ç°ä¸€äº›å¸¸è§çš„é”™è¯¯ï¼Œä½†æ˜¯ä¹Ÿæœ‰ä¸€äº›ä¸æ˜¯é”™è¯¯çš„ä»£ç è¢«è¯†åˆ«å‡ºæ¥ï¼ŒæŠ¥å‘Šé”™è¯¯ï¼Œè¿™ä¸ªæ—¶å€™éœ€è¦åŠ¨æ€ç±»å‹æ£€æŸ¥ï¼Œä½†æ˜¯å®é™…ä¸Šä¸ºäº†è®©æœ‰äº›ä¸æ˜¯é”™è¯¯çš„ä»£ç èƒ½å¤Ÿé€šè¿‡é™æ€ç±»å‹æ£€æŸ¥ï¼Œéœ€è¦ä¸€äº›ç‰¹æ®Šçš„æ–¹æ³•ï¼š

```
class A {}
class B interits A {}
class Main {
	x: A <- new A; // é™æ€æ£€æŸ¥å¯ä»¥é€šè¿‡ï¼Œå·¦å³ç±»å‹ä¸€è‡´
	...
	x <- new V; // é™æ€æ£€æŸ¥é€šä¸è¿‡ï¼Œå·¦å³ç±»å‹ä¸ä¸€è‡´
	...
}
```



ç†æƒ³æƒ…å†µä¸‹ï¼Œå¯¹äºæ‰€æœ‰çš„è¡¨è¾¾å¼ï¼šdynamic_type(E) <= static_type(E)





å¯¹äºä»»æ„è¡¨è¾¾å¼Eï¼Œdynamic_type(E) <= static_type(E)ï¼Œè¡¨ç¤ºè¡¨è¾¾å¼Eçš„é™æ€ç±»å‹æ£€æŸ¥å¾—åˆ°çš„ç±»å‹æ˜¯å¯¹åº”è¡¨è¾¾å¼åŠ¨æ€æ£€æŸ¥å¾—åˆ°å¾—ç±»å‹çš„çˆ¶ç±»

All operations that can be used on an object if type C can also be used on an object of type C' <= C

- Such as fetching the value of attribute

- Or invoking a method on the object

- Subclass only add attributes or methods

- ```
  
  ```

  



## Self Type

è€ƒè™‘å¦‚ä¸‹ä»£ç ï¼š

```java
class Count {
    i : int <- 0;
    inc () : Count {
        {
            i <- i + 1;
            self;
        }
    };
};
```

- ç±»CountåŒ…å«ä¸€ä¸ªè®¡æ•°å™¨ã€‚
- incæ–¹æ³•é€‚ç”¨äºä»»ä½•å­ç±»ã€‚
- è€ƒè™‘Countçš„å­ç±»Stock

```java
class Stock inherits Count { 
	name : String; -- name of item
};

class Main {
    Stock a <- (new Stock).inc();
    ... a.name ...
};
```

ä¸Šè¿°ç”¨æ³•åœ¨å·²æœ‰çš„ç±»å‹ç³»ç»Ÿä¼šæŠ¥é”™ï¼Œå› ä¸ºincè¿”å›çš„ç±»å‹æ˜¯Countï¼Œä½†ä½†æ˜¯èµ‹å€¼çš„å¯¹è±¡æ˜¯Stockå¯¹è±¡

- (new Stock).inc()å…·æœ‰åŠ¨æ€ç±»å‹Stockï¼›

- å› æ­¤å¦‚ä¸‹è¯­å¥æ˜¯åˆæ³•çš„;

  Stock a <- (new Stock).inc()ï¼›

- ä½†è¿™ä¸æ˜¯å¾ˆå¥½çš„ç±»å‹ç³»ç»Ÿï¼Œå› ä¸º(newStock).inc()çš„é™æ€ç±»å‹ä¸ºCountï¼›

- ç±»å‹æ£€æŸ¥å™¨â€œä¸¢å¤±â€ç±»å‹ä¿¡æ¯

  - è¿™ä½¿å¾—ç»§æ‰¿incæ¯«æ— ç”¨å¤„ ï¼›
  - å› æ­¤ï¼Œæˆ‘ä»¬å¿…é¡»ä¸ºæ¯ä¸ªå­ç±»é‡æ–°å®šä¹‰incï¼Œå¹¶ä½¿ç”¨ä¸“é—¨çš„è¿”å›ç±»å‹ ã€‚

è§£å†³ä¸Šè¿°é—®é¢˜éœ€è¦å¼•å…¥SELF_TYPE





æˆ‘ä»¬å°†ä½¿ç”¨self typeæ‰©å±•ç±»å‹ç³»ç»Ÿï¼š

- incè¿”å›selfï¼›
- å› æ­¤ï¼Œè¿”å›å€¼ä¸â€œselfâ€å…·æœ‰ç›¸åŒçš„ç±»å‹ï¼›
- å¯ä»¥æ˜¯Countæˆ–Countçš„ä»»ä½•å­ç±»å‹ï¼



å¼•å…¥å…³é”®å­—SELF_TYPEä»¥ç”¨äºæ­¤ç±»å‡½æ•°çš„è¿”å›å€¼ï¼ŒSELF_TYPEå…è®¸åœ¨ç»§æ‰¿incæ—¶æ›´æ”¹incçš„è¿”å›ç±»å‹

ä¿®æ”¹incçš„å£°æ˜ï¼š

```
inc(): SELF_TYPE {...}
```

 

ç±»å‹æ£€æŸ¥ç³»ç»Ÿç°åœ¨å¯ä»¥è¯æ˜ï¼š

```
O, M, C |- (new Count).inc(): Count
O, M, C |- (new Stock).inc(): Stock
```

æ³¨æ„SELF_TYPEä¸æ˜¯åŠ¨æ€ç±»å‹

- å®ƒä¹Ÿä¸æ˜¯ç±»åï¼›
- å®ƒæ˜¯é™æ€ç±»å‹ï¼›
- å¸®åŠ©ç±»å‹æ£€æŸ¥å™¨æ›´å¥½åœ°è·Ÿè¸ªç±»å‹ï¼›
- ä½¿ç±»å‹æ£€æŸ¥å™¨æ¥å—æ›´æ­£ç¡®çš„ç¨‹åº

ç®€è€Œè¨€ä¹‹ï¼Œæ‹¥æœ‰SELF_TYPEå¯ä»¥æé«˜ç±»å‹ç³»ç»Ÿçš„è¡¨è¾¾èƒ½åŠ›ã€‚



What can be the dynamic type of the object returned by inc ?ï¼ˆincå°†è¿”å›ä»€ä¹ˆæ ·çš„åŠ¨æ€ç±»å‹ï¼‰

- Answer: whatever could be the Count or any subclass of Count of 'self'



```
class A inherits Count {};

class B inherits Count {};

class C inherits Count {};
```



In genreral, if SELF_TYPE appears textually in the class C as the declared type of E then

```
dynamic_type(E) <= C
```

> Note: The meaning of SELF_TYPE depends on where it appears , $SELF\_TYPE_c$ refers to an occurence of SELF_TYPE in the body of C

$$
SELF\_TYPE_c <= C
$$

In type checking it is always safe to replace $SELF\_TYPE_c$ by  C
$$
SELF\_TYPE_c <= SELF\_TYPE_c
$$
in cool, we never compare SELF_TYPEs coming from different classes
$$
SELF\_TYPE_c <= T \quad if \quad C <= T
$$

- $SELF\_TYPE_c$ can be any subtype of c
- This includes C itself
- Thus this is the moe flexible rule we can allow

let T and T' be any types but SELF\_TYPE

1. $lub(SELF\_TYPE_c, SELF\_TYPE_c) = SELF\_TYPE_c$
2. $lub(SELF\_TYPE_c, T) = lub(C, T)$
3. $lub(T, SELF\_TYPE_c) = lub(C, T)$
4. $lub(T, T') defined as before$

**å“ªé‡Œä½¿ç”¨SELF_TYPE**



**self type checking**





## é”™è¯¯æ¢å¤

ä¸è§£æä¸€æ ·ï¼Œä»ç±»å‹é”™è¯¯ä¸­æ¢å¤ä¹Ÿå¾ˆé‡è¦

ç›®æ ‡ï¼š

- What type is assigned to an expresson with no legitimate type ?
- This type will influence the typing of the enclosing expression



**æ–¹æ³•1ï¼š**

assign type Object to ill-typed expressions

```
let y: Int <- x + 2 in y + 2
error: x is undefind: => x is Object
error: + applied to Object => x + 2 is Object 
error: bad assimend => ... (Int and Object is incompatible)
```



**æ–¹æ³•2:**

introduce `No_type` for use with ill-typed expressions

- DefineNo_type <= C for all types C
- Every operation os defined for No_type
  - With a. No_type result



```
let y: Int <- x + 2 in y + 2
x is No_type => x + 2 is No_type => no error becuse No_type is subtype of any type
```



æ€»ç»“ï¼š

å®é™…ç¼–è¯‘å™¨ä¹Ÿä¼šä½¿ç”¨ç±»ä¼¼No_typeçš„ä¸œè¥¿

ç„¶è€Œï¼Œå¼•å…¥No_typeä¼šå¸¦æ¥è·Ÿå¤šå¤æ‚æ€§ï¼šç±»çš„ç»§æ‰¿ç»“æ„å°†ä¸å†æ˜¯æ ‘çŠ¶ï¼Œå› ä¸ºæ¯ä¸ªç±»éƒ½æœ‰ä¸€ä¸ªå­ç±»

> coolé‡Œä½¿ç”¨äº†ç¬¬ä¸€ç§æ–¹æ¡ˆ
>







